
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Carte interactive - Saisie adresse manuelle</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    #map { height: 100vh; }
    .filter-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      background: white;
      padding: 10px;
      z-index: 1000;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      max-width: 320px;
    }
    .filter-panel label, .filter-panel input, .filter-panel button {
      display: block;
      width: 100%;
      margin-top: 8px;
    }
    #distanceFilter, #distanceLabel {
      display: none;
    }
  </style>
</head>
<body>
<div class="filter-panel">
  <label for="addressInput">üìç Adresse de r√©f√©rence :</label>
  <input type="text" id="addressInput" placeholder="Tapez votre adresse">
  <button onclick="geocodeAddress()">Valider</button>

  <label for="distanceFilter">üìè Distance (km) :</label>
  <input type="range" id="distanceFilter" min="10" max="100" value="30" step="10" oninput="updateDistanceFilter(this.value)">
  <span id="distanceLabel">30</span> km

  <label>üë∑‚Äç‚ôÇÔ∏è Filtrer par m√©tier :</label>
  <div id="metierFilters"></div>
</div>
<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
const map = L.map('map').setView([46.5, 4.5], 7);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

let referencePoint = null;
let referenceMarker = null;
let referenceCircle = null;
let currentRadius = 30000;
let markers = [];

const colorMap = {
  "Plomberie": "blue",
  "√âlectricien": "green",
  "Carreleur": "orange",
  "Plaquiste": "purple",
  "Menuisier": "yellow",
  "Tout corps d'√©tat": "red"
};

function getIconForMetier(metier) {
  const color = colorMap[metier] || "gray";
  return L.icon({
    iconUrl: `https://maps.google.com/mapfiles/ms/icons/${color}-dot.png`,
    iconSize: [32, 32],
    iconAnchor: [16, 32]
  });
}

function addMarker(data) {
  const { Nom, Adresse, M√©tier, Contact, Label, lat, lon } = data;
  const point = L.latLng(lat, lon);
  const marker = L.marker(point, { icon: getIconForMetier(M√©tier) }).bindPopup(
    `<b>${Nom}</b><br>${Adresse}<br><i>${M√©tier}</i><br>${Contact}<br>${Label}`
  );
  marker._rawData = data;
  marker.addTo(map);
  markers.push(marker);
}

function updateFilters() {
  if (!referencePoint) return;
  const selectedMetiers = Array.from(document.querySelectorAll('.metier-filter:checked')).map(cb => cb.value);
  markers.forEach(marker => {
    const data = marker._rawData;
    const dist = referencePoint.distanceTo(marker.getLatLng());
    const visible = dist <= currentRadius && selectedMetiers.includes(data.M√©tier);
    if (visible) {
      marker.addTo(map);
    } else {
      map.removeLayer(marker);
    }
  });
  if (referenceCircle) {
    referenceCircle.setRadius(currentRadius);
  }
}

function updateDistanceFilter(km) {
  document.getElementById('distanceLabel').innerText = km;
  currentRadius = km * 1000;
  updateFilters();
}

function geocodeAddress() {
  const address = document.getElementById('addressInput').value;
  if (!address) return alert("Merci de saisir une adresse.");
  fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}`)
    .then(res => res.json())
    .then(data => {
      if (data && data[0]) {
        const lat = parseFloat(data[0].lat);
        const lon = parseFloat(data[0].lon);
        referencePoint = L.latLng(lat, lon);
        map.setView(referencePoint, 11);

        if (referenceMarker) map.removeLayer(referenceMarker);
        referenceMarker = L.marker(referencePoint, { icon: L.icon({
          iconUrl: 'https://maps.google.com/mapfiles/ms/icons/red-dot.png',
          iconSize: [32, 32],
          iconAnchor: [16, 32]
        })}).addTo(map).bindPopup("Point de r√©f√©rence").openPopup();

        if (referenceCircle) map.removeLayer(referenceCircle);
        referenceCircle = L.circle(referencePoint, {
          radius: currentRadius,
          color: '#ff0000',
          fillColor: '#f03',
          fillOpacity: 0.1
        }).addTo(map);

        document.getElementById('distanceFilter').style.display = 'block';
        document.getElementById('distanceLabel').style.display = 'inline';

        updateFilters();
      } else {
        alert("Adresse introuvable.");
      }
    });
}

function updateMetierFilters(metiers) {
  const container = document.getElementById("metierFilters");
  container.innerHTML = "";
  metiers.forEach(m => {
    const label = document.createElement("label");
    label.innerHTML = `<input type="checkbox" class="metier-filter" value="${m}" checked> ${m}`;
    container.appendChild(label);
    container.appendChild(document.createElement("br"));
  });
  document.querySelectorAll('.metier-filter').forEach(cb => cb.addEventListener('change', updateFilters));
}

fetch("entreprises.json")
  .then(response => response.json())
  .then(data => {
    const metiersSet = new Set();
    data.forEach(entry => {
      addMarker(entry);
      metiersSet.add(entry.M√©tier);
    });
    updateMetierFilters([...metiersSet]);
  });
</script>
</body>
</html>
